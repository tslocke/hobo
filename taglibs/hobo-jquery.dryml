<!--

This is the jQuery plugin for Hobo.  This plugin provides the jQuery UI widgets in a Hobo friendly manner, provides useful tags and functions for jQuery javascript coding, and provides additional composite tags.

To use, see the [installation instructions](http://cookbook.hobocentral.net/plugins/hobo-jquery)  [(alternate link)](README.html)

The jQuery UI tags support all of the [options that the corresponding jQuery UI widgets provide](http://docs.jquery.com/UI).  For example:

    <datepicker dateFormat="yy-mm-dd" />

Options that expect a type other than string can be provided by passing a ruby object:

    <datepicker dayNamesMin="&['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa']" />

Events are also supported.  Pass in a global Javascript function name:

    <datepicker onSelect="hjq.util.log" />

-->

<!--
These are the Hobo jQuery and jQuery assets required by Hobo jQuery.  You will probably wish to add this to your page definition:
-->
<def tag="hjq-assets">
  <jquery-assets/>
  <hobo-jquery-assets/>
</def>

<def tag="jquery-assets">
  <stylesheet name='smoothness/jquery-ui-1.8.11.custom.css' />
  <javascript name="jquery.js" />
  <javascript name="jquery-ui.js" />
  <javascript name="jquery_ujs.js" />
</def>

<def tag="hobo-jquery-assets">
  <stylesheet name='hobo-jquery.css' />
  <javascript name="hobo-jquery/hjq.js" />
  <repeat with="&%w(form formlet select-many live-editor click-editor datepicker sortable-collection delete-button spinner filter-menu autocomplete input-many dialog live-search search-results combobox hot-input accordion tabs)">
    <javascript name="hobo-jquery/hjq-#{this}.js"/>
  </repeat>
  <javascript name="combobox.js"/>
  <script type="text/javascript">
    jQuery(document).ready(function() {
      $(this).hjq();
    });
  </script>
</def>


<!--
This is the [jQuery-UI datepicker](http://docs.jquery.com/UI/Datepicker).  All options and events are supported.

It's probably easiest to add this to your application.dryml:

    <def tag="input" for="Date">
      <datepicker dateFormat="yy-mm-dd" merge />
    </def>

It's probably useful to set global options such as dateFormat in application.dryml and set local options such as yearRange in the tag invocation:

    <input:birthdate yearRange="1900:#{Date.today.year}" />

New in version 1.4:

If you do not specify dateFormat, we will attempt to convert I18n.t(:"date.formats.default") from strftime format into the format that the JQuery-UI datepicker likes.

-->
<def attrs="name" tag="datepicker">
<%
  options, attrs = attributes.partition_hash(['altField', 'altFormat', 'appendText', 'buttonImage', 'buttonImageOnly', 'buttonText', 'changeMonth', 'changeYear', 'closeText', 'constrainInput', 'currentText', 'dateFormat', 'dayNames', 'dayNamesMin', 'dayNamesShort', 'defaultDate', 'duration', 'firstDay', 'gotoCurrent', 'hideIfNoPrevNext', 'isRTL', 'maxDate', 'minDate', 'monthNames', 'monthNamesShort', 'navigationAsDateFormat', 'nextText', 'numberOfMonths', 'prevText', 'selectOtherMonths','shortYearCutoff', 'showAnim', 'showButtonPanel', 'showCurrentAtPos', 'showMonthAfterYear', 'showOn', 'showOptions', 'showOtherMonths', 'stepMonths', 'yearRange'])
  options["dateFormat"]||=begin
                            d=I18n.t(:"date.formats.default")
                            {"%Y" => "yy",
                             "%y" => "y",
                             "%m" => "mm",
                             "%_m" => "m",
                             "%-m" => "m",
                             "%B" => "MM",
                             "%^B" => "MM",
                             "%b" => "M",
                             "%^b" => "M",
                             "%h" => "M",
                             "%d" => "dd",
                             "%-d" => "d",
                             "%j" => "oo",
                             "%D" => "mm/dd/y",
                             "%F" => "yy-mm-dd",
                             "%x" => "mm/dd/y"}.each {|rb, js| d.gsub!(rb,js)}
                           d
                         end
  events, html_attrs = attrs.partition_hash(['beforeShow', 'beforeShowDay', 'onChangeMonthYear', 'onClose', 'onSelect'])
  add_data_rapid!(html_attrs, "datepicker", :options => options, :events => events)
%>
 <%= text_field_tag(name, this, deunderscore_attributes(html_attrs)) %>
</def>


<!--
This is the [jQuery-UI autocompleter](http://jqueryui.com/demos/autocomplete/).  All options and events provided by the jQuery autocompleter are supported in this Hobo tag.   Refer to the jquery autocomplete documentation for more details.

If you do not provide a `source` option, this tag will essentially provide a default similar to this:

    <hjq-autocomplete:project source="&Project.find(:all, :limit => 5000).map {|p| p.name}" />

This will provide a local autocomplete, putting all possible options into your HTML.  This is useful when you have too many options to make a `select-one` infeasible, but will overload your server and crash your browser if you have millions of options.

To do server side autocomplete, you need a controller action like:

    class FoosController < ActionController:Base
      hobo_user_controller
      autocomplete :bar
    end

    <hjq-autocomplete:foo source="&complete_bar_foos_path" />

The argument to the controller's `autocomplete` is optional.  If not supplied the name attribute for the model should be used in the source attribute.

If you do not wish to use the Hobo autocomplete or hobo_completions functions in your controller, it is very easy to roll your own.   For example:

    <hjq-autocomplete:project source="&query_projects_path" delay="500" minLength="3" />

Could be served by:

    index_action :query do
      render :json => Project.name_contains(params[:term]).limit(100).*.name
    end

-->
<def tag="autocomplete" attrs="nil-value">
<%
  options, attrs = attributes.partition_hash(['disabled', 'appendTo', 'autoFocus', 'delay', 'minLength', 'position', 'source'])
  events, html_attrs = attrs.partition_hash(['create', 'search', 'open', 'focus', 'select', 'close', 'change'])
  options["source"] ||= begin
                          complete_target = this_field_reflection.klass
                          complete_target.find(:all, :limit => 5000).*.send(complete_target.name_attribute)
                        end

  html_attrs["name"] ||= param_name_for_this
  html_attrs["value"] ||= name(:no_wrapper => true, :if_present => true)

  if(html_attrs["value"].empty?)
    add_classes!(html_attrs, "nil-value")
    html_attrs["value"] = nil_value
  end

  add_data_rapid!(html_attrs, "autocomplete", :options => options, :events => events)
 %>
  <wrap tag="span" class="field-with-errors" when="&!this_parent.errors[this_field].empty?">
    <input type="text" merge-attrs="&html_attrs"/>
  </wrap>
</def>


<!-- Creates an enhanced version of the [jQuery-UI demo combobox](http://jqueryui.com/demos/autocomplete/#combobox).  This will turn any select (even a select-many) into a combobox.

Standard usage:

    <combobox>
      <select .../>
    </combobox>

If you don't supply the select, it will use Hobo's `<input>` tag.  This is usually the right default.

You can tell Hobo to always use a combobox for select-one, select-many, select-input and/or select-menu.   Notice that we also changed the limit - 100 is the default, which makes sense for a select, but not for a combobox.

    <extend tag="select-one">
      <combobox tag="select-one">
        <old-select-one limit="5000" merge/>
      </combobox>
    </extend>

To make the behavior more like the demo's, turn off autoFill and clearButton:

    <combobox autoFill="&false" clearButton="&false"/>

Combobox is a new control that is built on autocomplete.   The autocomplete options may not be used directly.   If you need any of them let me know, they should not be too hard to add if you volunteer to test them.

### Attributes

- `autoFill` (default: true):  select first value rather than clearing if there's a match

- `clearButton` (default: true): add a "clear" button

- `adjustWidth` (default: true): if true, will set the autocomplete width the same as the old select.  (requires jQuery 1.4.4 to work on IE8)

- uiStyle (default: false): if true, will add classes so that the autocomplete input takes a jQuery-UI style.  If false, the standard Hobo style is used.

### Events

- `selected` (default: `$(this).trigger('change');`):
-->

<def tag="combobox">
<%
  options, attrs = attributes.partition_hash(['autoFill', 'clearButton', 'adjustWidth', 'uiStyle'])
  events, html_attrs = attrs.partition_hash(['selected'])
  add_data_rapid!(html_attrs, "combobox", :options => options, :events => events)
%>
  <span class="combobox" param="default" merge-attrs="&html_attrs">
    <input merge param />
  </span>
</def>


<!-- Creates a sub-section of the form which the user can repeat using (+) and (-) buttons, in order to allow an entire `has_many` collection to be created/edited in a single form.

This tag is very different from tags like `<select-many>` and `<check-many>` in that:

 - Those tags are used to *choose existing records* to include in the association, while `<input-many>` is used to actually create or edit the records in the association.

### Example

Say you are creating a new `Category` in your online shop, and you want to create some initial products *in the same form*, you can add the following to your form:

    <input-many:products fields="name, price"/>

which is the same as

    <input-many:products><field-list fields="name, price"/></input-many>

The body of the tag will be repeated for each of the current records in the collection, or will just appear once (with blank fields) if the colleciton is empty.

### Attributes

 - fields:  If you do not specify any content for the input-many, a `<field-list>` is rendered.   This attribute is passed through to the `<field-list>`

 - skip:  Passed through to the `<field-list>`.  If not specified, it defaults to the parent association.

 - `minimum`: the minimum number of items in the collection.  Currently only '0' and '1' are supported values.  The default is '0'.

 - `template`: the default values for new items.  Normally this functionality is better provided by Model.new, but it's here if you need it.

 - `add-hook`, `remove-hook`: javascript hooks which work similarly to the events described below.

### Events

 - `rapid:add`: fired after the element is inserted

 - `rapid:remove`: fired before the element is inserted.  Returning false will cancel the removal.

 - `rapid:change`: fired after an element has been removed or inserted.

Example javascript:

      var last_added;
      var last_removed;
      $(document).ready(function() {
        $('.stories').on('rapid:add', function(ev) {
          last_added = this;
        });
        $('.stories').on('rapid:remove', function(ev) {
          last_removed = this;
          if(!confirm("really?")) return false;
        });
      });

Most of the enhancements from hjq-input-many have been folded back into hjq-input-many, but there are a few remaining differences:

 - it supports delayed initialization, required for some Javascript elements like the jQuery UI datepicker
 - the name of the main parameter is `item` rather than `default`
 - hjq-input-many allows you to provide javascript callbacks.  input-many fires
    rapid:add, rapid:change and rapid:remove events that can be hooked.

### Example

Say you are creating a new `Category` in your online shop, and you want to create some initial products *in the same form*, you can add the following to your form:

    <hjq-input-many:products fields="name, price" />

You'll often want to provide the `item` parameter:

    <hjq-input-many:products><item:><field-list fields="name, price" /></item:></hjq-input-many>

A fully worked up example of nested hjq-input-many's may be found in [agility/jquery-test](http://github.com/tablatom/agility/blob/jquery-test/app/views/projects/nested_has_many_test.dryml)

### Attributes

 - `minimum`: the minimum number of items in the collection.  Currently only '0' and '1' are supported values.  The default is '0'.

 - `fields`: passed down to the `field-list` tag in the default `item`.

 - `template`: the default values for new items.  Normally this functionality is better provided by Model.new, but it's here if you need it.

 - `add-hook`: a javascript function to call after an item has been added.  The context will be set to the new item.

 - `remove-hook`: a javascript function to call before an item is removed.  The context will be set to the item.  If the hook returns false, the remove is cancelled.


  -->
<def tag="input-many" attrs="minimum, fields, skip, more-skip, template, add-hook, remove-hook, hide, show" polymorphic >
<%
# helper function to create id's on buttons to facilitate testing
def underize(s)
  s.gsub(/\[/,"_").gsub(/\]/,"")
end
%>
  <set empty="&this.empty?"/>
  <% template ||= this.try.new_candidate || this.member_class.new -%>
  <% minimum ||= 0 ; minimum = minimum.to_i -%>
  <% skip ||= this.proxy_reflection.klass.reflect_on_all_associations.detect {|p| p.primary_key_name==this.proxy_reflection.primary_key_name}.try.name.to_s if this.respond_to? :proxy_reflection -%>
  <% skip += ",#{more_skip}" if more_skip -%>
  <% js_attrs = all_attributes.slice(:minimum, :add_hook, :remove_hook, :hide, :show) %>
  <% js_attrs[:prefix] = param_name_for_this %>
  <ul class="input-many #{this_field.dasherize}" data-rapid="#{data_rapid('input-many', js_attrs)}" merge-attrs>
    <fake-field-context fake-field="-1" context="&template">
      <li class="input-many-li input-many-template" id="#{underize param_name_for_this}">
        <div class="input-many-item" param="default">
          <field-list param merge-attrs="fields" skip="&skip" />
        </div>
        <div class="buttons">
          <button param="remove-item" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </li>
    </fake-field-context>
    <li class="input-many-li empty #{'hidden' unless this.empty? and minimum==0}" id="#{underize param_name_for_this}_-1_empty">
      <!-- HACK way to signal an empty collection to the controller -->
      <input type="hidden" class="empty-input" id="#{underize param_name_for_this}" name="#{param_name_for_this}" value="" disabled="&(!this.empty? || minimum>0)" />
      <fake-field-context fake-field="-1" context="&template">
        <div param="empty-message">
          <ht key="#{this.class.to_s.underscore}.collection.empty_message">
            No <%= this.class.name.titleize.downcase.pluralize %>.
          </ht>
        </div>
        <div class="buttons">
          <button param="remove-item" class="hidden" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </fake-field-context>
    </li>
    <fake-field-context fake-field="0" context="&template">
      <li class="input-many-li" if="&(this_parent.empty? && minimum>0)" id="#{underize param_name_for_this}">
        <div class="input-many-item" param="default">
          <field-list param merge-attrs="fields" skip="&skip" />
        </div>
        <div class="buttons">
          <button param="remove-item" class="hidden" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </li>
    </fake-field-context>
    <li repeat class="input-many-li #{'record-with-errors' unless this.errors.empty?}" id="#{underize param_name_for_this}">
      <error-messages without-heading class="sub-record"/>
      <hidden-id-field/>
      <div class="input-many-item" param="default">
        <field-list param merge-attrs="fields" skip="&skip" />
      </div>
      <div class="buttons">
        <button param="remove-item" class="#{'hidden' if this_parent.length<=minimum}" id="#{underize param_name_for_this}_remove">-</button>
        <button param="add-item" class="#{'hidden' if not last_item?}" id="#{underize param_name_for_this}_add">+</button>
      </div>
    </li>
  </ul>
</def>

<!--
    This is the default item used by `<hjq-input-many>`.  Redefine or extend if desired.
-->
<def tag="hjq-input-many-item" attrs="fields">
  <card param="default">
    <header: replace />
    <body:><field-list merge-attrs="fields" /></body:>
  </card>
</def>

<!--
`<formlet>` works like an AJAX `<form>` without actually being an AJAX `<form>`.  This is useful in scenarios where forms aren't allowed or are problematic, like inside of another form.

### Attributes

 - standard Hobo HTML attributes (id, part, et cetera).  All supported.

 - standard Hobo AJAX attributes:  (see [the cookbook](http://cookbook.hobocentral.net/api_taglibs/rapid_forms) )
   
   - `update`: (optional).  The DOM ID's of parts to update.  Note that you get an AJAX formlet whether this is provided or not.

   - `message`: the spinner message

   - `spinner-next-to`: DOM id of an element to position the ajax progress spinner next to.

   - `before`, `success`, `error`, `complete`: These callbacks are slightly different from the standard form callbacks.  They are called with "this" set to the formlet.  Also, you may pass in a function name rather than a javascript fragment.  If the before callback returns false, it will cancel the submission.

   - `confirm`: a message to be displayed in a JavaScript confirm dialog. By default there is no confirm dialog

   - not supported: `type, script, params, reset-form, refocus-form, result-update`.  None of these are particularly hard to support.  Email or post a message to the list if you need them.

 - standard Hobo Form attributes (all supported):

   - `hidden-fields`

   - `action`

   - `method`

   - `web-method`

   - `lifecycle`

   - `owner`
-->
<def tag="formlet" polymorphic attrs="element">
<%
  body, html_attrs, ajax_attrs, form_attrs = form_helper(attributes, parameters)
  element ||= 'div'
  unless body.nil?
    add_classes!(html_attrs, "formlet")
    add_data_rapid!(html_attrs, :formlet, :form_attrs => form_attrs, :ajax_attrs => ajax_attrs)
%>
    <%= element(element, html_attrs, body) %>
<%
  end
%>
</def>


<!--
`<form>` has been extended in Rapid to make it easier to construct and use forms with Hobo models. In addition to the base
`<form>` tag, a form with contents is generated for each Hobo model. These are found in
`app/views/taglibs/auto/rapid/forms.dryml`.

### Usage

`<form>` can be used as a regular HTML tag:

        <form action="/blog_posts/1" method="POST">...</form>

If no `action` attribute is provided then the context is used to construct an appropriate action using restful routing:

* If the context is a new record then the form action will be a `POST` to the create action:

        <form with="&BlogPost.new">...</form> -> <form action="/blog_posts" method="POST">...</form>

* If the context is a saved record then the form action will be a `PUT` to the update action. This is handled in a special
  way by Rails due to current browsers not supporting `PUT`, the method is set to `POST` with a hidden input called `_method`
  with a value of `PUT`. Hobo adds this automatically:

        <% blog_post = BlogPost.find(1) %>
        <form with="&blog_post">...</form> ->
        <form action="/blog_posts/1" method="POST">
          <input id="_method" type="hidden" value="PUT" name="_method"/>
          ...
        </form>

AJAX based submission can be enabled by simply adding an `update` attribute. e.g.

        <div part="comments"><collection:comments/></div>
        <form with="&Comment.new" update="comments"/>

More information on Ajax can be viewed in the [manual](/manual/ajax#forms) or in the [Rapid Forms index](/api_taglibs/rapid_forms).

### Additional Notes

- Hobo automatically inserts an `auth_token` hidden field if forgery protection is enabled

- Hobo inserts a `page_path` hidden field in create / update forms which it uses to re-render the correct page if a
  validation error occurs.

- `<form>` supports all of the standrd ajax attributes - (see the main taglib docs for Rapid Forms)

- `<form>` resets `last_if` if it does not have permission to display the form.   The `<else>` clause may be used to display alternate content.   For example:

    <form>...</form>
    <else>You do not have permission to edit this form</else>

or on a standard generated page using a default form:

    <some-page>
      <after-form:>
        <else>You do not have permission to edit this form</else>
      </after-form:>
    </some-page>

### Attributes

 - [all AJAX attributes](/api_taglibs/rapid_forms)

 - action: the controller action.  Default is create or update as appropriate

 - method: PUT or POST

 - web-method

 - lifecycle

 - owner

 - multipart: if set, the encoding is set to multipart/form-data.  The default is x-www-form-urlencoded

 - reset-form: Clear the form after submission (only makes sense for ajax forms)

 - refocus-form: Refocus the first form-field after submission (only makes sense for ajax forms)

### Parameters

The standard form tag does not have any parameters, nor does it have any default content.   However, Hobo does autogenerate polymorphic form tags for each of your models into `app/views/taglibs/auto/rapid/forms.dryml`.  These forms have the following parameters:

 - error-messages

 - field-list

 - actions

 - submit

 - cancel

-->
<def tag="form" polymorphic >
<%
  body, html_attrs, ajax_attrs, form_attrs = form_helper(attributes, parameters)
  unless body.nil?
    add_data_rapid!(html_attrs, :form, :ajax_attrs => ajax_attrs) unless ajax_attrs.empty?
%>
    <%= element("form", html_attrs.merge(form_attrs), body) if body %>
<% end %>
</def>


<!--
Submit button for use with `<formlet>`.  DEPRECATED: This tag is no longer needed in current versions of hobo-jquery:  the standard `<submit>` will work in a formlet now.

-->
<def tag="formlet-submit" attrs="label, image, method">
  <% label ||= 'submit' %>
  <if test='&image'>
    <input class='image-button formlet-submit-button' type='image' src='&image' onClick='hjq.formlet.submit.call(this)' merge-attrs />
  </if>
  <else>
    <input class='button formlet-submit-button' type='button' value='#{label}' onClick='hjq.formlet.submit.call(this)' merge-attrs />
  </else>
</def>

<!--
The JQuery UI [dialog](http://jqueryui.com/demos/dialog/).  All options and methods are supported.

The default for [autoOpen](http://jqueryui.com/demos/dialog/#option-autoOpen) has been changed to `"&false"`.  To display the dialog set autoOpen to `"&true"`, use a `<dialog-open-button>`, use `<dialog-and-button>` or use javascript (`$('#foo-dialog').hjq_dialog('open');`).

The [buttons](http://jqueryui.com/demos/dialog/#option-buttons) option has been changed slightly.  Because of quoting issues, it's usually easier to assign the list to a variable and then include the list:

    <% buttons = [ ["cancel", "jQuery(this).dialog('close')"] ] %>
    <dialog buttons="&buttons">My dialog text</dialog>

or

    <dialog id="story-dialog" buttons='&{"cancel" => "jQuery(this).dialog(\"close\")"}' >My dialog text</dialog>

or

    <dialog id="story-dialog" buttons='&{"cancel" => "hjq.dialog.close"}' > FIXME</dialog>

Because Ruby 1.8 Hash's do not preserve order, you may use a list of pairs instead of a Hash.

If you do not set [position](http://jqueryui.com/demos/dialog/#option-position) the dialog will appear where it is defined in your DRYML.

JQuery UI is sometimes picky about types.   For instance, the width option must be a number, not a string.  By default Hobo options are strings, but you can easily send a number by using the ampersand to switch to ruby mode:

    <dialog width="&640"/>

The following functions are predefined for use in dialog buttons:  FIXME

 * `hjq.dialog.close`:  close the dialog box
 * `hjq.dialog.submitFormlet`:  submits all formlets inside the dialog
 * `hjq.dialog.submitFormletAndClose`: submits any enclosed formlets, then closes the dialog.
-->
<def tag="dialog-box" attrs="buttons">
<%
 options, attrs = attributes.partition_hash(["autoOpen", "bgiframe", "closeOnEscape", "dialogClass", "draggable", "height", "hide", "maxHeight", "maxWidth", "minWidth", "modal", "position", "resizable", "show", "stack", "title", "width", "zIndex"])
 events, html_attrs = attrs.partition_hash(["beforeclose", "open", "focus", "dragStart", "drag", "dragStop", "resizeStart", "resize", "resizeStop", "close"])
 options["autoOpen"]=false unless options.has_key?("autoOpen")
%>
 <span class="dialog-position"></span>
 <% html_attrs = add_classes(html_attrs, "hidden dialog-box") %>
 <div merge-attrs="&html_attrs" data-rapid="&data_rapid('dialog-box', :options => options, :events => events, :buttons => buttons)" param="default" />
</def>

<!--
When pressed, will open a `<dialog-box>`.

### Attributes
 * `dialog` (required):a CSS selector (AKA jQuery selector) to locate the dialog in the DOM.  Remember, if you're passing an ID, place a '#' in front of the ID.
 * supports all `<button>` attributes

### Example
    <dialog id="hello-dialog">Hello!</dialog>
    <dialog-open-button dialog="#hello-dialog">Press Me!</dialog-open-button>
-->
<def tag="dialog-open-button" attrs="dialog">
  <button data-rapid="&data_rapid('dialog-open-button', :selector => dialog)" param="default" class="dialog-open-button" merge />
</def>

<!--
Defines an `<dialog-box>` and a `<dialog-open-button>` and links the two together.

### Attributes
 * `id` (optional): the DOM id to use for the dialog
-->
<def tag="dialog-and-button">
  <% # we can't use jQuery traversal functions since the dialog will move around in the DOM %>
  <% attributes["id"]="dialog-#{(rand*1000000000).to_i}" unless attributes.has_key?("id") %>
  <dialog-box param merge />
  <dialog-open-button dialog="##{attributes['id']}" param />
</def>

<!--
Defines a `<select-one>` and a button that brings up an `<dialog>` containing a form allowing you to enter a new item.  After the form is filled in and closed, the `<select-one>` is changed to select the new item.

### Caveats

`select-one-or-new-dialog` is a very simple control that depends on a large number of Hobo and hobo-jquery components to be working correctly in the standard manner.   These include ajax, a standard form context, and formlets.

#### sort order

The javascript for this control is a quick hack that assumes the new item created will be the last item in the select.   If you've defined a sort order, this assumption will be broken.   It will also be broken if there are more items than the select-one limit.

#### parameterizing parts

Because the select-one is a part, it cannot be parameterized.  However, you can adjust its definition by defining the polymorphic input for the type:

    <def tag="input" for="StoryStatus">
      <select-one include-none="&false" />
    </def>

#### controller actions

For Hobo ajax to work, standard controller actions are required.   If you have customized the sub-item's create action, you may break select-one-or-new-dialog.

There is one case where you have to customize the create action.   For Ajax to work, Hobo has to resurrect the context.   This is straightforward if the parent context exists in the database.   If it does not, then Hobo uses whatever 'this' is created by the controller action.   In our case, this is usually the wrong thing.

Example:

    class Story
      hobo_model
      fields do
        name :string
      end
      belongs_to :story_status
      # plus permissions, etc...
    end

app/views/stories/new.dryml:

    <new-page>
      <field-list:>
        <story-status-view:>
          <select-one-or-new-dialog/>
        </story-status-view:>
      </field-list:>
    </new-page>

app/controllers/story_statuses_controller.rb:

    class StoryStatusesController < ApplicationController
      def create
        hobo_create do
          if request.xhr?
            self.this = Story.new
          end
        end
      end
    end

Just to be clear, you shouldn't need any special controller actions if
you are using inside of edit forms.  It's only when you're using it
inside of a new form that Hobo cannot load the object from the
database so you have to tell it the context.

FIXME: translate 'or', 'New', 'cancel', 'ok'.

-->
<def tag="select-one-or-new-dialog">
  <% dialog_id="dialog-#{typed_id.gsub(':', '-')}" %>
  <% part_id = "select-one-#{typed_id.gsub(':', '-')}" %>
  <input part="select-one-or-new-dialog-select" id="#{part_id}" />
  <span param="or">or</span>
  <dialog-open-button dialog="##{dialog_id}" param>
    New <%= this_field_name %>
  </dialog-open-button>
  <dialog-box param buttons='&[["cancel", "hjq_dialog_box.close"], ["ok", "hjq_dialog_box.submitAndClose"]]' title="New #{this_field.humanize}" id="&dialog_id" > 
    <formlet with="&this_type.new" update="&part_id" success="jQuery('##{part_id} select').val(jQuery('##{part_id} option:last').val())">
      <field-list param/>
    </formlet>
  </dialog-box>
</def>


<!--
An in-place-editor type control.  Displays the `view` view of a field
until it's clicked on, when it switches to the `input` view.  Onchange
the field is saved via Ajax, and onblur the view switches back to the
`view` view.

Due to the way the DRYML part system works, `<click-editor>` may not
be parameterized.  If you wish to parameterize it, see
`<click-editor-innards>`.
-->
<def tag='click-editor'>
  <div part="editor-part">
    <click-editor-innards/>
  </div>
</def>

<!--
When placed inside of a part, provides a complete parameterizable `<click-editor>`.

### Usage

    <part name="my-part">
      <click-editor-innards>
        <before-view:>My</before-view:>
        <view: replace>
          My <view restore/>
        </view: replace>
      </click-editor-innads>
    </part>

### Attributes

The ajax effect options `hide` and `show` adjust the effects used when clicking on the element.  To adjust the effects on update, set `hide` and `show` on the `formlet:` parameter.

All other ajax options are also supported.

blank-message: the message to display if the field is blank.  Note
that you're probably better off changing this via translations
(hobo.in_place_editor.click_to_edit).

-->
<def tag='click-editor-innards' attrs="blank-message">
  <%
  blank_message ||= t('hobo.in_place_editor.click_to_edit', :default => '(click to edit)')
  effect_attrs,attributes = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_EFFECT_ATTRS)
  ajax_attrs,attributes = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_ATTRS)
  data = data_rapid('click-editor', effect_attrs)
  %>
    <if>
      <view class="in-place-edit hidden" data-rapid="&data" param/>
    </if>
    <else>
      <view with="&blank_message" class="in-place-edit hidden" data-rapid="&data" param="blank-view"/>
    </else>
    <set my-field="&this_field"/>
    <formlet with="&this_parent" class="in-place-form" ajax errors-ok merge-attrs="&ajax_attrs" param>
      <error-messages param/><%# TODO: replace with something more compact, maybe even transient %>
      <input field="&my_field" param/>
    </formlet>
</def>

<!--
A simpler in-place-editor type control.  Renders an `input` of the
field that is automatically saved via Ajax onchange.

Due to the way the DRYML part system works, `<live-editor>` may not
be parameterized.  If you wish to parameterize it, see
`<live-editor-innards>`.
-->
<def tag='live-editor'>
  <div part="live-editor-part">
    <live-editor-innards/>
  </div>
</def>

<!--
When placed inside of a part, provides a complete parameterizable `<click-editor>`.

### Usage

    <part name="my-part">
      <live-editor-innards hide="puff"/>
    </part>

### Attributes

Attributes are merged onto the supporting formlet, so all formlet
attributes are supported.  Many don't make sense to customize, but
others such as `hide` and `show`, do.

-->
<def tag='live-editor-innards'>
  <set my-field="&this_field"/>
  <formlet with="&this_parent" class="in-place-form" ajax errors-ok data-rapid="&data_rapid('live-editor')" param merge>
    <error-messages param/><%# TODO: replace with something more compact, maybe even transient %>
    <input field="&my_field" param/>
  </formlet>
</def>


<%# FIXME: rename old input, make sure it's still available if anybody wants it %>
<def tag="input" for="Date">
  <datepicker merge/>
</def>

<def tag="editor" polymorphic>
  <%# if polymorphism fails %>
  <live-editor merge/>
</def>
<def tag="editor" for="string"><click-editor merge /></def>
<def tag="editor" for="text"><click-editor merge /></def>
<def tag="editor" for="html"><click-editor merge /></def>
<def tag="editor" for="datetime"><click-editor merge /></def>
<def tag="editor" for="date"><click-editor merge /></def>
<def tag="editor" for="integer"><click-editor merge /></def>
<def tag="editor" for="BigDecimal"><click-editor merge /></def>
<def tag="editor" for="float"><click-editor merge /></def>
<def tag="editor" for="boolean"><live-editor merge /></def>
<def tag="editor" for="HoboFields::Types::EnumString"><live-editor merge /></def>

<!-- An enhanced version of Rapid's `<collection>` tag that supports drag-and-drop re-ordering.

Each item in the collection has a `<div class="ordering-handle" param="handle">` added, which can be used to drag the item up and down.

### Attributes

`sortable-collection` supports all of the options and events defined by [jQuery UI's Sortable](http://jqueryui.com/demos/sortable/).

Sortable also supports all of the standard [Hobo AJAX callbacks](http://cookbook.hobocentral.net/api_taglibs/rapid_forms).

The jQuery UI option `update` is used internally to save the new order via Ajax.   If you modify this option, your function may call `$(this).hjq_sortable_collection('update')` to retain this functionality.

### Controller support

This tag assumes the controller has a `reorder` action and the model has a `position_column` method. This action is added automatically by Hobo's model-controller if the model declares `acts_as_list`. See also [Drag and Drop Reordering](/manual/controllers#drag_and_drop_reordering) in the [Controllers and Routing](/manual/controllers) chapter of the manual.
-->
<def tag="sortable-collection">
<%
  options, attrs = attributes.partition_hash(['disabled', 'appendTo', 'axis', 'cancel', 'connectWith', 'containment', 'cursor', 'cursorAt', 'delay', 'distance', 'dropOnEmpty', 'forceHelperSize', 'forcePlaceholderSize', 'grid', 'handle', 'helper', 'items', 'opacity', 'placeholder', 'revert', 'scroll', 'scrollSensitivity', 'scrollSpeed', 'tolerance', 'zIndex'])
  events, html_attrs = attrs.partition_hash(['create', 'start', 'sort', 'change', 'beforeStop', 'stop', 'update', 'receive', 'remove', 'over', 'out', 'activate', 'deactivate'])
  ajax_attrs, html_attrs = attrs.partition_hash(Hobo::Rapid::Helper::AJAX_CALLBACKS)

  singular_name = this.member_class.name.underscore
  route_method = subsite ? "#{subsite}_reorder_#{singular_name.pluralize}_url" : "reorder_#{singular_name.pluralize}_url"
  reorder_url = send(route_method)

  add_classes!(html_attrs, "sortable-collection")
  add_data_rapid!(html_attrs, "sortable-collection", :options => options, :events => events, :ajax_attrs => ajax_attrs, :reorder_url => reorder_url, :reorder_parameter => "#{singular_name}_ordering")
%>
  <collection class="sortable" merge-attrs="&html_attrs" merge-params>
    <item: param>
      <div class="ordering-handle" param="handle" if="&can_edit?(this.position_column)">&uarr;<br/>&darr;</div>
      <do param="default"><card param/></do>
    </item:>
  </collection>
</def>

<!-- adds support for hide, show attrs -->
<extend tag="select-many">
  <% effect_attrs, attributes = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_EFFECT_ATTRS)
  %>
  <old-select-many data-rapid="&data_rapid('select-many', effect_attrs)" merge/>
</extend>

<!-- Provides either an ajax or non-ajax delete button to send a
     RESTful "DELETE". The context should be a record for which you to
     want provide a delete button.

There are three possible types of `delete-button` created.

### Non-Ajax

No Ajax is used if

 - the `update`, `updates` and `ajax` attributes are not set AND EITHER
 - `in-place` is explicitly set false OR
 - the context for the delete is the same as the top-level context for the page.   In other words, if you're trying to delete the entire page.

### Standard form Ajax

If you set the `update`, `updates` or `ajax` attributes, standard form/part AJAX is used.   It's assumed that the part you're specifying includes the item to be deleted so that it will be removed from the page by the update.

### "Magic" Ajax

If:

 - the `update`, `updates` and `ajax` attributes are not set AND EITHER
 - `in-place` is explicitly set true OR
 - the context for the delete is not the same as the top-level context for the page.   In other words, if you're not trying to delete the entire page.

then `delete-button` performs an Ajax delete and then attempts to fix up the page.   It does this by removing all items on the page that have their hobo-rapid-context set to the item being deleted.   If said deletion results in an empty list, it shows the `.empty-collection-message`.   This procedure should work with `<collection>`, `<table>` and their children (`<sortable-collection>`, `<table-plus>`, etc.).

### Attributes

All the standard ajax attributes *except the callbacks* are supported (see the main taglib documention for Rapid Forms).

 - label: The label for the button. Default: "Remove".  (Alternately, use the hobo.actions.remove translation to customize)

 - in-place: see above

 - image: URL of an image for the button.

 - fade: Perform the fade effect (true/false)? Default: true

 - confirm: has a default value of "Are you sure?" or hobo.messages.confirm translated.  You must explicitly set this to false if you don't want a confirm message.

  -->
<def tag="delete-button" attrs="label, in-place, image, confirm, fade, subsite"><%
  url = object_url(this, :method => :delete, :subsite => subsite)
  if url && can_delete?
    in_place = !(this == @this && request.method.downcase == "get") if in_place.nil?
    update_attrs, attributes = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_UPDATE_ATTRS)
    ajax_attrs, attributes = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_ATTRS)
    attributes[src] = "#{base_url}/images/#{image}" if image
    label ||= t("hobo.actions.remove", :default=>"Remove")
    confirm = t("hobo.messages.confirm", :default=>"Are you sure?") if confirm.nil?

    add_classes!(attributes,
                 image ? "image-button" : "button",
                 "delete-button delete-#{this.class.name.underscore.dasherize}-button")

    if in_place && update_attrs.blank?
      data_rapid = data_rapid(:delete_button)
      ajax_attrs[:update] ||= ""   # force form ajax
      ajax_attrs[:confirm] = confirm
    elsif !update_attrs.blank?
      ajax_attrs.merge!(update_attrs)
      ajax_attrs[:confirm] = confirm
      data_rapid = nil
    else
      data_rapid = nil
    end
  end
%>
  <if test="&url && can_delete?">
    <form method="delete" action="&url" class="button_to" merge-attrs="&ajax_attrs" data-rapid="&data_rapid" data-rapid-context="&typed_id" data-confirm="&confirm">
      <input type="submit" value="&label" merge/>
    </form>
  </if>
</def>


<!-- Repeats the body of the tag inside a `<ul>` list with one item for each object in the collection (`this`). If no body is given, renders a `<card>` inside the `<li>`.

Automatically adds 'even' and 'odd' CSS classes as well as the data-rapid-context attribute.

`empty-collection-message` is called from this tag.   To suppress you can use the `without-empty-message` pseudo-attribute:

    <collection without-empty-message/>

If your collection is an ActiveRecord result set (and in Hobo it most likely is), the best way to customize the empty message is via translations.   Example: for product models, the key to customize would be `products.collection.empty_message`.

If your collection is a generic array, empty-collection-message doesn't work.   `<collection>` also sets the last_if flag, so you can use the `<else>` tag to display a message:

    <collection with="&[]"/>
    <else>No items.</else>
 -->
<def tag="collection" attrs="list-tag">
  <% list_tag ||= 'ul' %>
  <call-tag tag="&list_tag" class="collection #{collection_name :dasherize => true}" merge-attrs unless="empty?">
    <li param="item" class="#{scope.even_odd}" data-rapid-context="&typed_id" repeat="&select_viewable">
      <do param="default"><card param/></do>
    </li>
  </call-tag>
  <empty-collection-message param="empty-message"/>
  <if/><%# set last-if so <else/> works %>
</def>

<!-- Renders a message such as "No products to display". If the collection (`this`) is empty, `style="display:none"` is added. This means the message is still present and can be revealed with JavaScript if all items in the collection are removed via ajax remove buttons.

The message can be customized via the `empty-collection-message` parameter or by changing the `products.collection.empty_message` translation.
  -->
<def tag="empty-collection-message">
  <unless test="&this._?.member_class.nil?">
    <div class="empty-collection-message" style="#{'display:none' if !this.empty?}" param="default">
      <ht key="#{this.member_class.name.underscore}.collection.empty_message">
        No <collection-name/> to display
      </ht>
    </div>
  </unless>
</def>

<def tag="qunit-includes">
  <stylesheet name="qunit"/>
  <javascript name="qunit"/>
</def>

<def tag="qunit-banner">
  <h1 id="qunit-header">QUnit</h1>
  <h2 id="qunit-banner"></h2>
  <h2 id="qunit-userAgent"></h2>
  <ol id="qunit-tests">
  </ol>
</def>

<extend tag="page">
  <old-page merge>
    <scripts:>
      <do param="custom-scripts"/>

      <javascript param="application-javascript" name="application"/>
    </scripts:>

    <ajax-progress: class="ajax-progress"/>
  </old-page>
</extend>

<def tag="page-scripts">
  <do param="default">
    <%= tag("span", :style => "display: none;", "data-rapid-page-data" => data_rapid_page_data(attributes)) %>
  </do>
</def>


<!-- A `<select>` menu intended to act as a filter for index pages.

### Example

Filtering on state is a common use.   Here's the dryml for Order:

    <filter-menu param-name="state" options="&Order::Lifecycle.states.keys" />

And the controller action:

    def index
      # always validate data given in URL's!!!
      params[:state]=nil unless Order::Lifecycle.states.include?(params[:state]._?.to_sym)
      finder = params[:state] ? Order.send(params[:state]) : Order
      hobo_index finder
    end

See [Filtering stories by status](/tutorials/agility#filtering_stories_by_status) in the [Agility Tutorial](/tutorials/agility) for an example.

### Attributes

Standard AJAX attributes such as 'update' are supported.   If any are supplied, filter-menu uses Ajax rather than a page refresh.

 - `param-name` - the name of the HTTP parameter to use for the filter
 - `options` - an array of options or an array of arrays (useful for localized apps) for the menu.
   It can be omitted if you provide the options as an array or array of arrays in the locale file.
 - `no-filter` - The text of the first option which indicates no filter is in effect. Defaults to 'All'
 - `first-value` - the value to be used with the first option. Typically not used,
 meaning the option has a blank value.
 - model - the model name (optional: needed if you use the "activerecord.attributes" namespace.

### I18n

It lookups the options attributes in `activerecord.attributes.#{model}.filter_menu.#{param\_name}.options`
with fallback to `filter_menu.#{param_name}.options`.
The passed options are used as a default in case the lookup fails.
Besides the `activerecord.attributes.#{model}.filter_menu.#{param_name}.no_filter` or
`tags.filter_menu.default.no_filter` key is used as default of the attribute "no-filter"
(or "All" if no default is found)

### I18n Example


    es:
      activerecord:
        attributes:
          <model_name>:
            filter_menu:
              period:
                no_filter: Todos Períodos
                options:
                - [ "Hoy", "today" ]
                - [ "Ayer", "yesterday" ]

or

    es:
      tags:
        filter_menu:
          period:
            no_filter: Todos Períodos
            options:
            - [ "Hoy", "today" ]
            - [ "Ayer", "yesterday" ]


     TIME_PERIODS = %w[today yesterday]

     <t-filter-menu param-name="period" options="&TIME_PERIODS" no-filter="All Periods"/>

  with I18n.locale == :es

     <select name="period">
       <option value="">Todos Períodos</option>
       <option value="today">Hoy</option>
       <option value="yesterday">Ayer</option>
     </select>

  with I18n.locale == :en (i.e no locale file)

     <select name="period">
       <option value="">All Periods</option>
       <option value="today">today</option>
       <option value="yesterday">yesterday</option>
     </select>

  -->
<def tag="filter-menu" attrs="model, param-name, options, no-filter, id, first-value">
  <% options = t("activerecord.attributes.#{model}.filter_menu.#{param_name}.options", :default=>[:"tags.filter_menu.#{param_name}.options", options])
     raise ArgumentError, %(You must provide an "options" attribute, or set "activerecord.attributes.#{model}.filter_menu.#{param_name}.options" or "tags.filter_menu.#{param_name}.options" to an Array or to an Array of Arrays
     in your locale file(s)) unless options.is_a?(Array)
     no_filter = t("activerecord.attributes.#{model}.filter_menu.#{param_name}.no_filter", :default=>[:"tags.filter_menu.#{param_name}.no_filter", :"tags.filter_menu.default.no_filter", no_filter, "All"])
     %>
  <form action="&request.path" method="get" class="filter-menu" merge-attrs="&attributes"  data-rapid="&data_rapid('filter-menu')">
    <div>
      <% opt = options.first.kind_of?(Array) ? options.*.last : options
         selected = opt.detect {|o| o.to_s==params[param_name.gsub('-', '_')] }  %>
      <select-menu name="&param_name" options="&options" selected="&selected"
                   first-option="&no_filter" first-value="&first_value" key="&param_name" merge-params/>
      <hidden-fields for-query-string skip="page,#{param_name}"/>
    </div>
  </form>
</def>

<def tag="name-one" attrs="complete-target, completer, min-chars">
<%
  complete_target ||= this_field_reflection.klass
  completer ||= (complete_target.is_a?(Class) ? complete_target : complete_target.class).name_attribute
  source = polymorphic_url(complete_target, :action => "complete_#{completer}", :routing_type => :path)
  value = name(:no_wrapper => true, :if_present => true)
-%>
  <autocomplete source="&source" minLength="&min_chars || 1" merge/>
</def>


<!-- Provides an ajax-powered *find-as-you-type* live search field which is hooked up to Hobo's site-side search feature.

Customizing the display of results can be done through customizing the "box" param and the `search-results` tag.  The current definition of `<search-results>` expects results to be returned in `@search_results`.

TODO: currently you have to press 'return' to initiate the search.  This should be easy to fix in hjq-live-search.js - the hard part will probably be in doing it in a way that works in all possible browsers.

### attributes

- action: the path to send the query.  Default is "/search" (actually, site_search_path)
- query_param: the name of the param to use for the search.  Default is "query"

All other attributes are merged into the form, so standard form attributes are supported.
 -->
<def tag="live-search" attrs="query-param, panel-tag">
  <% attributes[:action] ||= site_search_path %>
  <% attributes[:update] ||= "search-results-part" %>
  <% attributes[:message] ||= t("hobo.live_search.spinner_message", :default => "Querying...") %>
  <% query_param ||= "query" %>
  <div class="search" data-rapid='{"live-search": {}}'>
    <form merge-attrs param refocus-form>
      <input type="hidden" value="2" name="search_version"/>
      <label for="&query_param" param><t key="hobo.live_search.label">Search</t></label><input type="search" name="&query_param" class="live-search" param/>
    </form>
    <% panel_tag ||= 'dialog-box' %>
    <% title = t("hobo.live_search.results_label", :default => "Search Results") %>
    <call-tag tag="&panel_tag" position="&{:my => 'right top'}" width="&600" height="&800" id="search-results-box" with="&nil" title="&title" param="box">
      <do part="search-results-part">
        <search-results/>
      </do>
    </call-tag>
  </div>
</def>

<!-- redefining or extending this tag will allow you to customize the display of search results -->
<def tag="search-results">
  <section with="&@search_results || []" data-rapid='{"search-results": {}}'>
    <collection/>
    <else><t key="hobo.live_search.no_results">Your search returned no matches.</t></else>
  </section>
</def>

<!--
`<table>` is extended in Rapid to provide a shorthand way to output a set of fields for a given collection. This is enabled using the `field` attribute (without the `field` attribute this is just the regular HTML `<table>` tag)

### Usage

If the context is an array of blog posts...

    <table fields="name, created_at, description"/>

This will output a header row containing "Name", "Created At" and "Description" followed by a row for each record in the collection. By default, the `<view/>` tag is called for each field in the row. This can be altered with the `field-tag` attribute, e.g.

    <table fields="name, created_at, description" field-tag="input"/>

This will use `<input/>` as the tag in each table cell instead of `<view/>`

### Additional Notes

* `<table>` provides parameters based on the names of the fields which can be used to further customise the output. For each field a heading parameter is provided, e.g. name-heading, created-at-heading, description-heading. These can be used to customise the headings:

        <table fields="name, created_at, description">
          <created-at-heading:>Creation Date</created-at-heading:>
        </table>
* Similarly, "view" parameters are provided as an additional way to customise the table cells of the table body, e.g. `name-view`, `created-at-view`, `description-view`:

        <table fields="name, created_at, description">
          <created-at-view:><view format="%d %B %Y"/></created-at-view:>
        </table>
* By adding an empty `control` parameter, the default control column is enable adding an edit link and delete button for each table row:

        <table fields="name, created_at, description">
          <controls:/>
        </table>

    The controls can be further customised using the "edit-link" and "delete-button" parameters:

        <table fields="name, created_at, description">
          <controls:/>
          <delete-button: label="Nuke Me"/>
        </table>

    or by providing completely new content for the control column:

        <table fields="name, created_at, description">
          <controls:>my controls!</controls:>
        </table>

### Using table without ActiveRecord

Typical usage for table is to supply the results of an ActiveRecord query as the context.   However, it is possible to supply a more generic array as the context instead.

#### using the tr parameter

If you use the tr parameter you can pass pretty much anything in the array, since you then are supplying the formatting for the row.  Giving:

    <table with="&[1,2,3]">
      <thead:><tr><th>Heading</th></tr></thead:>
      <tr:><td><%= this+7 %></td></tr:>
    </table>

Produces:

    <table>
      <thead>
        <tr><th>Heading</th></tr>
      </thead>
      <tbody>
        <tr class='odd fixnum'><td>8</td></tr>
        <tr class='even fixnum'><td>9</td></tr>
        <tr class='odd fixnum'><td>10</td></tr>
      </tbody>
    </table>

#### using OpenStruct

If you supply an array of generic objects, you can supply method names to fields and `<table>` will produce a valid table.   The only major difference from passing ActiveRecord objects is that this mechanism will not translating table headings.

If you've got a Hash, you can use OpenStruct to make the data available via methods.  Giving:

    <% require 'ostruct' %>
 {: .hidden}

    <table fields="a,b" with="&[OpenStruct.new(:a => 1, :b => 2), OpenStruct.new(:a => 3, :b => 4)]">
       <a-heading:>A</a-heading:>
       <b-heading:>B</b-heading:>
    </table>

Produces:

      <table>
        <thead>
          <tr class='field-heading-row'>
            <th class='a-heading'>A</th>
            <th class='b-heading'>B</th>
          </tr>
        </thead>
        <tbody>
          <tr class='odd open_struct'>
            <td class='a-view'><span class='view '>1</span></td>
            <td class='b-view'><span class='view '>2</span></td>
          </tr>
          <tr class='even open_struct'>
            <td class='a-view'><span class='view '>3</span></td>
            <td class='b-view'><span class='view '>4</span></td>
          </tr>
        </tbody>
      </table>

#### without the magic

If you don't use either the fields attribute or the tr parameter, all processing is turned off, and your table is emitted verbatim.  Giving:

    <table>
      <thead>
        <tr><th>a</th></tr>
      </thead>
      <tbody>
        <tr><td>b</td></tr>
      </tbody>
    </table>

Will emit the above table verbatim.

Produces:
 {: .hidden}

    <table>
      <thead>
        <tr><th>a</th></tr>
      </thead>
      <tbody>
        <tr><td>b</td></tr>
      </tbody>
    </table>
 {: .hidden}
-->
<def tag="table" attrs="fields, field-tag, empty">
  <if test="&!(fields || all_parameters.tr?)">
    <%= element("table", attributes, all_parameters.default) %>
  </if>
  <else>
    <% field_tag ||= "view" %>
    <unless test="&this.empty? && !empty">
      <%= element "table", attributes - attrs_for(:with_fields) do %>
      <thead if="&all_parameters[:thead] || fields" param>
        <tr param="field-heading-row">
          <with-field-names merge-attrs="&all_attributes & attrs_for(:with_fields)">
            <th param="#{scope.field_name}-heading"><%= this.member_class ? this.member_class.human_attribute_name(scope.field_name) : scope.field_name.to_s.titleize %></th>
          </with-field-names>
          <th if="&all_parameters[:controls]" class="controls"/>
        </tr>
      </thead>
      <tbody param>
        <repeat>
          <tr param if="&can_view?"
              class="#{scope.even_odd} #{this_type.name.underscore}" data-rapid-context="&typed_id">
            <if test="&fields">
              <with-fields merge-attrs="&all_attributes & attrs_for(:with_fields)" force-all>
                <td param="#{scope.field_name.to_s.sub('?', '').gsub('.', '-')}-view"><call-tag tag="&field_tag"/></td>
              </with-fields>
              <td class="controls" param="controls" if="&all_parameters[:controls]">
                <a param="edit-link" action="edit" if="&can_edit?">
                  <t key="hobo.actions.edit_control">Edit</t>
                </a>
                <delete-button param/>
              </td>
            </if>
          </tr>
        </repeat>
      </tbody>
      <tfoot if="&all_parameters[:tfoot]" param/>
      <% end %>
    </unless>
  </else>
</def>



<!--
This tag wraps an input with some ajax that refreshes a part when the input is changed.

An example of when this is useful is when a form is rendered differently depending on what country is selected.   In this example, we'll change the label of the region to state or province or whatever is appropriate for the country.

     <field-list: replace>
       <do part="shipping">
         <field-list fields="address,city,region,country,postal_code">
           <country-view:><hot-input ajax /><country-view:>
           <region-label:><%= this_parent.country._?.region_label %><region-label:>
         <field-list>
       </do>
     <field-list:>

The actual input is exposed as the default parameter, so it can be customized:

     <hot-input ajax selector="select">
       <combobox>
         <select-one limit="5000"/>
       </combobox>
     </hot-input>

Note also the selector option, which is useful for complex, combined inputs like a combobox.   A single change in a complex input may actually result in change events being fired on multiple fundamental HTML elements, so we use the selector to only watch a single input.

The hot-input must be inside a form, and the form's context must be the same as the page's context.   You can work around this limitation by using custom controller code.

### Attributes

This tag supports the [standard form AJAX attributes](/api_taglibs/rapid_forms), such as update, message, spinner-next-to, etc.

In particular, the part to update *must* be specified using either the `ajax`, `update` or `updates` attribute.

* path: the path to send the AJAX request to.   If not specified, the current page path is used.
* method: the HTTP method for the request.   Defaults to 'GET'.
* events: the javascript event(s) to trigger on.  Default is 'change'.
* selector: filter for the events.  Default is null.

Note that `event` and `selector` are passed straight to `$.on()`  See [its documentation](http://api.jquery.com/on/) for more details.

-->
<def tag="hot-input" attrs="path, method, events, selector" >
<%
  attributes['message'] ||= 'Loading...'
  ajax_attrs, html_attrs = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_ATTRS)
  add_data_rapid!(html_attrs, "hot-input", :ajax_attrs => ajax_attrs, :path => path || request.path, :method => method || 'GET', :events => events || 'change', :selector => selector)
%>
  <span class="hot-input" param="default" merge-attrs="&html_attrs">
    <input merge param />
  </span>
</def>


<!-- This tag, when given a list, chunks the list using the [jQuery-UI accordion](jqueryui.com/demos/accordion).

If you do not specify the `chunker` attribute, the list is chunked into sections of equal length.   The default is 20 items, but that may be adjusted by setting the `per-section` attribute.

The `chunker` may be passed a block to specify custom chunking.   This block is passed to (Enumerable#chunk)[http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-chunk]  For example, to divide a sorted list of users based on the first letter of their name:

    <accordion-collection:users chunker="&Proc.new{|u| u.name[0..1]}"/>

The scoped variable `chunk` is set to the chunker output.   If you didn't specify the chunker, it's set to the chunk number.   In the example above, it would be set to the first letter of the user's name.   Here's an example of it being used to customize the chunk heading:

    <heading:>Section <%= scope.chunk %></heading:>

The context is set to the chunked list for all parameters.   This allows us to further customize the heading:

    <header:><name:first/> &mdash; <name:last/></header:>

Replacing the collection with a table is easy:

    <default:><table fields="this,email"/></default:>

Remember that the default parameter is a list, even if you set per-section="1".   The easiest way to explode a list is with `<repeat>`:

    <accordion-collection per-section="1">
      <header:><name:first/></header:>
      <default:>
        <repeat>
          This is my content: <view/>
        </repeat>
      </default:>
    </accordion-collection>


### Note:

This tag uses Enumerable#chunk, which is only available with Ruby 1.9.2 and later.   If you are using Ruby 1.8.7, you must include the `backports` gem in your project.

-->
<def tag="accordion-collection" attrs="per-section,chunker,sortable">
  <% options, attrs = attributes.partition_hash(['disabled', 'active', 'animated', 'autoHeight', 'clearStyle', 'collapsible', 'event', 'fillSpace', 'header', 'icons', 'navigation'])
     events, html_attrs = attrs.partition_hash(['navigationFilter', 'create', 'change', 'changestart'])
     add_classes!(html_attrs, "accordion-collection")
     add_data_rapid!(html_attrs, "accordion", :options => options, :events => events, :sortable => sortable)
     %>
  <div merge-attrs="&html_attrs">
  <% per_section ||= 20 %>
  <% per_section = per_section.to_i %>
  <% counter = 0 %>
  <% chunker ||= Proc.new{|el| counter=counter+1; (counter-1)/per_section+1} %>
  <repeat with="&this.to_a.chunk(&chunker)">
    <% chunk, list = this %>
    <% list.member_class = this.member_class if this._?.member_class%>
    <set-scoped chunk="&chunk">
      <do with="&list">
        <div class="hjq-accordion-element">
          <h3 param="header-wrapper">
            <a param="header" href="#"><%= scope.chunk %></a>
          </h3>
          <div param="default">
            <collection without-empty-message param/>
          </div>
        </div>
      </do>
    </set-scoped>
  </repeat>
  </div>
</def>

<%# This tag allows you to easily use [jQuery-UI tabs](http://jqueryui.com/demos/tabs/)

    <tabs>
      <first:>tab 1 content</first:>
      <tab2:>tab 2 content</tab2:>
    </tabs>

If you don't specify any attributes to the parameters, the parameter name is used for the tab name and ID.   You can adjust this behaviour by specifying attributes to your parameters:

    <tabs>
      <tab1: name="1" id="id1">tab 1 content</tab1:>
    </tabs:>

If you specify an href rather than an id, the tab content is loaded dynamically:

    <tabs>
      <remote: href="/front/hello"/>
    </tabs>

Attributes are passed through to jQuery-UI, so options and events defined in the [jQuery-ui tabs documentation](http://jqueryui.com/demos/tabs/) may be used:

    <tabs collapsible selected="2">
      ...
    </tabs>

### Attributes

Note that `tabs` supports attributes both on the `tabs` tag as well as on the parameters.

The parameters support three attributes:  `id`, `name`, `href`, described above.

The `tabs` tag supports all options and events supported in jQuery-UI, plus one additional attribute:

* sortable:  if set, the tabs are sortable rather than fixed.

### Notes

Usage of Ruby 1.8 will result in an undefined tab order.   Ruby 1.9 is recommended.

%>
<def tag="tabs" attrs="sortable">
  <% options, attrs = attributes.partition_hash(['disabled', 'ajaxOptions', 'cache', 'collapsible', 'cookie', 'deselectable', 'disabled', 'event', 'fx', 'idPrefix', 'panelTemplate', 'selected', 'spinner', 'tabTemplate'])
     events, html_attrs = attrs.partition_hash(['create', 'select', 'load', 'show', 'add', 'remove', 'enable', 'disable'])
     add_classes!(html_attrs, "tabs")
     add_data_rapid!(html_attrs, "tabs", :options => options, :events => events, :sortable => sortable)
     %>
  <div merge-attrs="&html_attrs">
    <ul>
      <repeat with="&parameters">
        <% attrs, params = this.call %>
        <li><a href="#{attrs[:href] || '#'+(attrs[:id] || this_key.to_s)}"><%= attrs[:name] || this_key.to_s.titleize %></a></li>
      </repeat>
    </ul>

    <repeat with="&parameters">
      <% attrs, params = this.call %>
      <% merge_attrs = attrs - [:id, :href, :name] %>
      <div id="#{attrs[:id] || this_key}" merge-attrs="&merge_attrs"><%= params[:default]._?.call %></div>
    </repeat>
  </div>
</def>

<%#
 The `<accordion>` tag implements the [jQuery-UI accordion](http://jqueryui.com/demos/accordion/).  It works the same as the `<tabs>` tag, so see the [tabs documentation](/api_tag_defs/tabs) for more information

     <accordion>
       <section1:>Hello</section1:>
       <section2:>Hey</section2:>
     </accordion>

There is one difference:  accordion does not support the `href` option.
%>
<def tag="accordion" attrs="sortable">
  <% options, attrs = attributes.partition_hash(['disabled', 'active', 'animated', 'autoHeight', 'clearStyle', 'collapsible', 'event', 'fillSpace', 'icons', 'navigation'])
     events, html_attrs = attrs.partition_hash(['navigationFilter', 'create', 'change', 'changestart'])
     add_classes!(html_attrs, "accordion")
     add_data_rapid!(html_attrs, "accordion", :options => options, :events => events, :sortable => sortable)
     %>
  <div merge-attrs="&html_attrs">
    <repeat with="&parameters">
      <div class="hjq-accordion-element">
        <% attrs, params = this.call %>
        <% merge_attrs = attrs - [:name] %>
        <h3><a href="#"><%= attrs[:name] || this_key.to_s.titleize %></a></h3>
        <div merge-attrs="&merge_attrs"><%= params[:default]._?.call %></div>
      </div>
    </repeat>
  </div>
</def>



<!--
`<a>` is extended in Rapid to automatically provide URLs for Hobo model routes

### Usage

The tag behaves as a regular HTML link or anchor if either the href or name attribute is given:

    <a href="/admin">Admin</a> -> Output is exactly as provided, untouched by Rapid

If no href or name is given then the _context_ is used to determine the link URL.
The helper method `object_url` is used to construct the URL using restful routing:

If the context is a class then the link will be an index page:

    <a with="&BlogPost">My Blog</a> -> <a href="/blog_posts">My Blog</a>

If the context is a hobo model instance then the link will be a show page:

    <% blog_post = BlogPost.find(1) %>
    <a with="&blog_post">My Blog Post</a> -> <a href="/blog_posts/1">My Blog Post</a>

An action can be provided for an alternative show page:

    <a with="&blog_post" action="edit">Edit Post</a> -> <a href="/blog_posts/1/edit">Edit Post</a>

Or a new page if the context is a class:

    <a with="&BlogPost" action="new">New Blog Post</a> -> <a href="/blog_posts/new">New Blog Post</a>

### Additional Features

* If the constructed route does not exist then the link will not be created, but the content of the link will still be output. E.g. when `/blog_posts` does not exist (because the hobo model controller does not exist or the index action is disabled):

        <a with="&BlogPost">My Blog</a> -> My Blog

    when the show action `/blog_posts/:id` does not exist:

        <a with="&blog_post">My Blog Post</a> -> My Blog Post
* If no content text is provided then `<a>` will use the name method on the context to provide the text. E.g.

        <a with="&blog_post"/> -> <a href="/blog_posts/1">My First Blog Post</a>`
        <a with="&BlogPost"/> -> <a href="/blog_posts">Blog Posts</a>`
* If `action="new"` then `<a>` will check that the current user has permission to create the object
* Several useful classes are added automatically to the output `<a>`.

### AJAX

The standard AJAX form attributes are supported.  This can be used for conventional Ajax:

    <a href="&refresh_path" update="results">Refresh results</a>

Or it can be used with push-state to provide faster links:

    <a href="somewhere/else" update="body" push-state new-title="Somewhere else">Go somewhere else.</a>

In this case the entire body is being refreshed but the headers
aren't, so will work to link between two dissimilar pages as long as
the headers are identical.

AJAX attributes are supported in both modes: in the "magic" mode where
RAPID determines the href target or in "passthrough" where you supply
the href or name.

### Attributes

The standard AJAX attributes are supported.

* action:  If "new", triggers the special behaviour listed above.  Otherwise, contains the action to be performed on the context.   If neither `action` nor `method` are specified, the action will be "index" or "show", as appropriate.

* to:  Use this item as the target instead of the current context.

* params:  These are appended to the target as a query string after a "?".  Params are passed as a ruby hash.  Example: `params="&{id=>17, name=>'joe'}"`

* query-params: if set, current query parameters are mirrored onto the link.   If true or blank, all non-ajax query parameters are used.   (`query-params`, `query-params="&true"` or `query-params=""`)  Otherwise, the specified query parameters are used.   (`query-params="page,sort,search"`)

* href, name:  If either of these attributes are present, the smart features of this tag are turned off.

* format: this adds ".#{format}" to the end of the url

* subsite: routes the URL using the subsite

* force: overrides the permission check if `action` is "new"

* method: "get", "put", "post" or "delete".  "get" is the default

-->
<def tag="a" attrs="action, to, params, query-params, href, format, subsite, force"><%=
  content = parameters.default

  ajax_attrs, attributes = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_ATTRS)
  unless ajax_attrs.blank?
    add_data_rapid!(attributes, "a", :ajax_attrs => ajax_attrs)
  end


  if query_params
    if query_params==true || query_params.blank?
      query_params = query_parameters_filtered
    else
      query_params = query_parameters_filtered(:only => comma_split(query_params))
    end
    params = query_params.merge(params || HashWithIndifferentAccess.new)
  end

  if href || attributes[:name]
    # Regular link
    href += "?" + params.map { |n, v| "#{n}=#{v}" }.join('&') if !params.blank?
    element(:a, attributes.update(:href => href), content)
  else
    target = to || this

    if target.nil?
      Dryml.last_if = false
      nil_view
    elsif action == "new"
      # Link to a new object form
      new_record = target.new
      new_record.set_creator(current_user)
      href = object_url(target, "new", params._?.merge(:subsite => subsite))

      if href && (force || can_create?(new_record))
        new_class_name = if target.respond_to?(:proxy_reflection)
                           target.proxy_association.reflection.klass.name
                         else
                           target.name
                         end

        add_classes!(attributes, "new-#{new_class_name.underscore}-link")
        content = "New #{new_class_name.titleize}" if content.blank?
        Dryml.last_if = true
        element(:a, attributes.update(:href => href), content)
      else
        Dryml.last_if = false
        ""
      end
    else
      # Link to an existing object

      content = name if content.blank?

      href = object_url(target, action, (params || {}).merge(:subsite => subsite)) unless (action.nil? && target.try.new_record?)
      if href.nil?
        # This target is registered with Hobo::Routes as not linkable
        content
      else
        css_class = target.try.origin_attribute || target.class.name.underscore.dasherize
        add_classes!(attributes, "#{css_class}-link")

        href.sub!(/\?|$/, ".#{format}\\0") unless format.blank?

        # Set default link text if none given
        element(:a, attributes.update(:href => href), content)
      end
    end
  end
%></def>


<!-- An enhanced version of Rapid's `<table>` that has support for column sorting, searching and pagination.

This tag calls `<table merge-params>`, so the parameters for `<table>` are also available.

The enhancements made available in this tag require controller support.

An [worked example](/tutorials/agility#improve_the_project_page_with_a_searchable_sortable_table) of this tag is available in the [Agility Tutorial](/tutorials/agility)

### Attributes

All attributes supported by `<table>` and `<with-fields>` are supported.

AJAX attributes are passed through to the sort links and the search form.

sort-field: defaults to @sort_field, if that is available.  `parse_sort_params` sets this variable

sort-direction: 'asc' or 'dec'.   defaults to @sort_direction, if that is available.   `parse_sort_params` sets this variable

sort-columns: a hash that allow you to map fields to sortable columns.   The default is {"this" => "name"} (or whatever column that has the :name option set on it).

-->
<def tag="table-plus" attrs="sort-field, sort-direction, sort-columns" >
  <% sort_field ||= @sort_field; sort_direction ||= @sort_direction; sort_columns ||= {} %>
  <% sort_columns['this'] ||= this.member_class.try.name_attribute %>
  <% ajax_attrs, attributes = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_ATTRS) %>
  <div class="table-plus" merge-attrs="&attributes - attrs_for(:with_fields) - attrs_for(:table)">
    <div class="header" param="header">
      <div class="search">
        <form param="search-form" method="get" action="" with="&nil" merge-attrs="&ajax_attrs" >
          <hidden-fields for-query-string skip="page, search"/>
          <span><t key="hobo.table_plus.search">Search</t></span>
          <input class="search" type="search" name="search" value="&params[:search]"/>
          <submit label="&t('hobo.table_plus.submit_label', :default=>'Go')" class="search-button" param="search-submit"/>
        </form>
      </div>
    </div>

    <table merge-attrs="&attributes & (attrs_for(:table) + attrs_for(:with_fields))" empty merge-params>
      <field-heading-row:>
        <with-field-names merge-attrs="&all_attributes & attrs_for(:with_fields)">
          <% col = sort_columns[scope.field_path] || scope.field_path
             sort = sort_field == col && sort_direction == 'asc' ?
                      "-#{col}" : col
             sort_url = url_for_page_path(query_parameters_filtered('except' => 'page').merge(:sort => sort))
             col_heading_name = this.member_class.try.human_attribute_name(scope.field_name, :default=> scope.field_name.titleize) %>

          <th param="#{scope.field_name}-heading">
            <a href="&sort_url" class="column-sort"
               param="#{scope.field_name}-heading-link" merge-attrs="&ajax_attrs" ><%= col_heading_name %></a>
            <if test="&col == sort_field">
              <do param="up-arrow" if="&sort_direction == 'desc'">&uarr;</do>
              <do param="down-arrow" if="&sort_direction == 'asc'">&darr;</do>
            </if>
          </th>
        </with-field-names>
        <th if="&all_parameters[:controls]" class="controls"></th>
      </field-heading-row>
    </table>
    <empty-collection-message param="empty-message"/>

    <page-nav param if="&this.respond_to?(:page_count) || this.respond_to?(:total_pages)" merge-attrs="&ajax_attrs" />
  </div>
</def>


<def tag="hidden-field">
  <%= hidden_field_tag(param_name_for_this, this, deunderscore_attributes(attributes)) %>
</def>


<!--- A simple wrapper around the `will_paginate` helper. All options to `will_paginate` are available as attributes.  If you do not specify `params`, it will be guessed. -->
<def tag="page-nav" attrs="params">
  <%  ajax_attrs, attributes = attributes.partition_hash(Hobo::Rapid::Helper::AJAX_ATTRS) %>
  <%= will_paginate this, attributes.symbolize_keys.reverse_merge(:inner_window => 2, :previous_label => translate("hobo.actions.previous", :default=>"« Prev"), :next_label =>translate("hobo.actions.next", :default=>"Next »"), :params => recognize_page_path.slice(:controller,:action,:id), :extra_attributes => (ajax_attrs.empty? ? {} : {"data-rapid" => {"a" => {"ajax_attrs" => ajax_attrs}}.to_json}), :ignore_params => [:render, :render_options, :"_"]) %>
</def>



